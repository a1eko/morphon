#!/usr/bin/env python

"Neuron morphology repair tool"

from __future__ import print_function, division
from morphon import Morpho, measure, rotation
import numpy as np
import argparse
import random
import os


verbose = False
quiet = False

def parse():
    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument("file", type=str, help="input file (swc)", nargs='+')
    parser.add_argument("-O", "--dir", type=str, help="output directory")
    parser.add_argument("-s", "--seed", type=int, help="random seed value")
    parser.add_argument("-n", "--neurites", type=str, help="neurite types, comma separated")
    parser.add_argument("-v", "--verbose", help="verbose output", action="store_true")
    parser.add_argument("-q", "--quiet", help="no output", action="store_true")
    return parser.parse_args()


def split_tips(m, neurites=['dend'], outer_layer=0.25):
    inner_tips = []
    outer_tips = []
    sx, sy, sz = m.size()
    cmin, cmax = m.bounds()
    tips =  m.tips(neurites=neurites)
    for tip in tips:
        cx, cy, cz = m.coord(tip)
        depth = (cz-cmin[2])/sz
        if depth > outer_layer and depth < 1 - outer_layer:
            inner_tips.append(tip)
        else:
            outer_tips.append(tip)
    return inner_tips, outer_tips


def needs_repair(m, neurites=['dend'], outer_layer=0.25, order_thresh=0, length_thresh=0):
    repairable = False
    inner_tips, outer_tips = split_tips(m, neurites=neurites, outer_layer=outer_layer)
    if inner_tips and outer_tips:
        oorder = [m.order(i) for i in outer_tips]
        iorder = [m.order(i) for i in inner_tips]
        outer_tip_order = np.mean(oorder)
        inner_tip_order = np.mean(iorder)
        odev = np.std(iorder)
        odist = [m.distance(i) for i in outer_tips]
        idist = [m.distance(i) for i in inner_tips]
        outer_tip_dist = np.mean(odist)
        inner_tip_dist = np.mean(idist)
        ldev = np.std(idist)
        if (outer_tip_order < inner_tip_order - order_thresh*odev 
            or outer_tip_dist < inner_tip_dist - length_thresh*ldev):
                repairable = True
    return repairable


def repair_neurite(m, repair_candidate, inner_tips, order_thresh=0, length_thresh=0):
    repair_order = m.order(repair_candidate)
    repair_neurite = m.neurite(repair_candidate)
    orders = [m.order(i) for i in inner_tips]
    if repair_order > max(orders):
        return

    sections = []
    for ident in inner_tips:
        ss = m.sections(ident, reverse=True, neurites=[repair_neurite], orders=[repair_order])
        sections.extend(ss)
    if not sections: return
    lengths = []
    for sec in sections:
        lengths.append(sum(m.length(i) for i in sec))
    mean_length = np.mean(lengths)
    ldev = np.std(lengths)

    src_section = random.choice(sections)
    src = src_section[-1]

    repair_section = m.sections(repair_candidate, reverse=True, orders=[repair_order])[0]
    repair_seclength = sum(m.length(i) for i in repair_section)
    if repair_seclength < mean_length - length_thresh*ldev:
        stub_length = mean_length - repair_seclength
        length = 0
        for ident in reversed(src_section):
            length += m.length(ident)
            src = ident
            if length > stub_length:
                break
    if verbose: print('\t src', src)

    subtree = m.copy(src)
    feature_values = measure(subtree, features=['root_position', 'center_position'])
    c0 = np.array(feature_values['root_position'])
    c1 = np.array(feature_values['center_position'])
    source_vec = c1 - c0
    c0 = m.coord(repair_section[0])
    c1 = m.coord(repair_section[-1])
    target_vec = c1 - c0
    axis, angle = rotation(source_vec, target_vec)
    subtree.rotate(axis, angle)
    c0 = subtree.coord(subtree.root())
    c1 = m.coord(repair_candidate)
    subtree.translate(c1-c0)
    m.graft(repair_candidate, subtree)

    term_sections = m.sections(repair_candidate, degrees=[1])
    if verbose: print('\t term sections', len(term_sections))
    sections = []
    for ident in inner_tips:
        ss = m.sections(ident, reverse=True, neurites=[repair_neurite], degrees=[1])
        sections.extend(ss)
    lengths = []
    for sec in sections:
        lengths.append(sum(m.length(i) for i in sec))
    mean_length = np.mean(lengths)
    ldev = np.std(lengths)
    orders = []
    for sec in sections:
        orders.append(m.order(sec[0]))
    mean_order = np.mean(orders)
    odev = np.std(orders)

    for sec in term_sections:
        seclength = sum(m.length(i) for i in sec)
        if seclength > mean_length + length_thresh*ldev:
            trim_length = seclength - mean_length
            src = sec[-1]
            length = 0
            for ident in reversed(sec):
                length += m.length(ident)
                src = ident
                if length > trim_length:
                    break
            if verbose: print('\t trim', src)
            m.prune(src)

    for sec in term_sections:
        src = sec[0]
        secorder = m.order(src)
        if secorder > mean_order + order_thresh*odev:
            if verbose: print('\t trim sec', src)
            m.prune(src)


def repair(m, neurites=['dend'], outer_layer=0.25, order_thresh=0, length_thresh=0):
    inner_tips, outer_tips = split_tips(m, neurites=neurites, outer_layer=outer_layer)
    if verbose: print(outer_tips)
    for repair_candidate in outer_tips:
        if verbose: print(m.neurite(repair_candidate), repair_candidate)
        repair_neurite(m, repair_candidate, inner_tips, length_thresh=length_thresh)


def main():
    global quiet, verbose
    args = parse()
    if args.verbose:
        verbose = True
        quiet = False
    if args.quiet:
        quiet = True
        verbose = False
    if args.seed:
        random.seed(args.seed)
    neurites = args.neurites.split(',') if args.neurites else ['dend']
    for morphology in args.file:
        if not quiet: print(morphology)
        inp = os.path.dirname(os.path.abspath(morphology))
        out = args.dir if args.dir else inp
        name = os.path.basename(morphology).split('.')[0]
        m = Morpho(morphology)
        if needs_repair(m, neurites=neurites, outer_layer=0.1, order_thresh=0.2, length_thresh=0.2):
            if verbose: print('repairing', end=' ')
            repair(m, neurites=neurites, outer_layer=0.1, order_thresh=0.2, length_thresh=0.2)
        m.renumber(continuous=True)
        m.save(out + '/' + name + '-rep.swc')
        if verbose: print()


if __name__ == "__main__":
    main()
